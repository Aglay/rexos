/*
    RExOS - embedded RTOS
    Copyright (c) 2011-2015, Alexey Kramarenko
    All rights reserved.
*/

#include "tls_private.h"
#include "sys_config.h"
#include "../../userspace/tls.h"
#include "../../userspace/process.h"
#include "../../userspace/stdio.h"
#include "../../userspace/sys.h"
#include "../../userspace/io.h"
#include "../../userspace/so.h"
#include "../../userspace/tcp.h"
#include "../../userspace/endian.h"
#include "../crypto/pkcs.h"
#include <string.h>

void tlss_main();

typedef enum {
    //TODO: more states to go
    TLSS_STATE_CLIENT_HELLO = 0,
    TLSS_STATE_GENERATE_SERVER_RANDOM,
    TLSS_STATE_GENERATE_SESSION_ID,
    TLSS_STATE_SERVER_HELLO,
    TLSS_STATE_CLIENT_KEY_EXCHANGE,
    TLSS_STATE_DECRYPT_PREMASTER,
    TLSS_STATE_SERVER_CHANGE_CIPHER,
    TLSS_STATE_ESTABLISHED,
    TLSS_STATE_CLOSING,
    TLSS_STATE_MAX
} TLSS_STATE;

typedef struct {
    HANDLE handle;
    IO* rx;
    IO* tx;
    TLS_RANDOM client_random;
    TLS_RANDOM server_random;
    TLS_PROTOCOL_VERSION version;
    TLSS_STATE state;
    uint16_t cipher_suite;
    bool server_secure, client_secure;
} TLSS_TCB;

typedef struct {
    HANDLE tcpip, user, owner;
    uint8_t* cert;
    unsigned int cert_len;
    unsigned int offset;
    IO* rx;
    IO* tx;
    IO* user_tx;
    SO tcbs;
    bool user_tx_busy;
} TLSS;

const REX __TLSS = {
    //name
    "TLS Server",
    //size
    TLS_PROCESS_SIZE,
    //priority - midware priority
    TLS_PROCESS_PRIORITY,
    //flags
    PROCESS_FLAGS_ACTIVE | REX_FLAG_PERSISTENT_NAME,
    //function
    tlss_main
};

#if (TLS_DEBUG_REQUESTS)
typedef enum {
    TLS_KEY_EXCHANGE_NULL,
    TLS_KEY_EXCHANGE_RSA,
    TLS_KEY_EXCHANGE_DH_DSS,
    TLS_KEY_EXCHANGE_DH_RSA,
    TLS_KEY_EXCHANGE_DHE_DSS,
    TLS_KEY_EXCHANGE_DHE_RSA,
    TLS_KEY_EXCHANGE_DH_anon,
    TLS_KEY_EXCHANGE_KRB5,
    TLS_KEY_EXCHANGE_PSK,
    TLS_KEY_EXCHANGE_DHE_PSK,
    TLS_KEY_EXCHANGE_RSA_PSK,
    TLS_KEY_EXCHANGE_ECDH_ECDSA,
    TLS_KEY_EXCHANGE_ECDHE_ECDSA,
    TLS_KEY_EXCHANGE_ECDH_RSA,
    TLS_KEY_EXCHANGE_ECDHE_RSA,
    TLS_KEY_EXCHANGE_ECDH_anon,
    TLS_KEY_EXCHANGE_SRP_SHA,
    TLS_KEY_EXCHANGE_SRP_SHA_RSA,
    TLS_KEY_EXCHANGE_SRP_SHA_DSS,
    TLS_KEY_EXCHANGE_ECDHE_PSK,
    TLS_KEY_EXCHANGE_UNKNOWN
} TLS_KEY_EXCHANGE;

typedef enum {
    TLS_CIPHER_NULL,
    TLS_CIPHER_RC4_40,
    TLS_CIPHER_RC4_128,
    TLS_CIPHER_RC2_CBC_40,
    TLS_CIPHER_IDEA_CBC,
    TLS_CIPHER_DES40_CBC,
    TLS_CIPHER_DES_CBC_40,
    TLS_CIPHER_DES_CBC,
    TLS_CIPHER_3DES_EDE_CBC,
    TLS_CIPHER_SEED_CBC,
    TLS_CIPHER_AES_128_CBC,
    TLS_CIPHER_AES_256_CBC,
    TLS_CIPHER_AES_128_GCM,
    TLS_CIPHER_AES_256_GCM,
    TLS_CIPHER_AES_128_CCM,
    TLS_CIPHER_AES_256_CCM,
    TLS_CIPHER_AES_128_CCM_8,
    TLS_CIPHER_AES_256_CCM_8,
    TLS_CIPHER_CAMELIA_128_CBC,
    TLS_CIPHER_CAMELIA_256_CBC,
    TLS_CIPHER_CAMELIA_128_GCM,
    TLS_CIPHER_CAMELIA_256_GCM,
    TLS_CIPHER_ARIA_128_CBC,
    TLS_CIPHER_ARIA_256_CBC,
    TLS_CIPHER_ARIA_128_GCM,
    TLS_CIPHER_ARIA_256_GCM,
    TLS_CIPHER_UNKNOWN
} TLS_CIPHER;

typedef enum {
    TLS_HASH_NULL,
    TLS_HASH_MD5,
    TLS_HASH_SHA,
    TLS_HASH_SHA256,
    TLS_HASH_SHA384,
    TLS_HASH_NIL,
    TLS_HASH_UNKNOWN
} TLS_HASH;

static const char* const __TLSS_STATES[TLSS_STATE_MAX] =           {"CLIENT_HELLO",
                                                                    "GENERATE_SERVER_RANDOM",
                                                                    "GENERATE_SESSION_ID",
                                                                    "SERVER_HELLO",
                                                                    "CLIENT_KEY_EXCHANGE",
                                                                    "DECRYPT_PREMASTER",
                                                                    "SERVER_CHANGE_CIPHER",
                                                                    "ESTABLISHED",
                                                                    "CLOSING"};

static const char* const __TLS_KEY_ECHANGE[] =                     {"NULL",
                                                                    "RSA",
                                                                    "DH_DSS",
                                                                    "DH_RSA",
                                                                    "DHE_DSS",
                                                                    "DHE_RSA",
                                                                    "DH_anon",
                                                                    "KRB5",
                                                                    "PSK",
                                                                    "DHE_PSK",
                                                                    "RSA_PSK",
                                                                    "ECDH_ECDSA",
                                                                    "ECDHE_ECDSA",
                                                                    "ECDH_RSA",
                                                                    "ECDHE_RSA",
                                                                    "ECDH_anon",
                                                                    "SRP_SHA",
                                                                    "SRP_SHA_RSA",
                                                                    "SRP_SHA_DSS",
                                                                    "ECDHE_PSK"};


static const char* const __TLS_CIPHER[] =                          {"NULL",
                                                                    "RC4_40",
                                                                    "RC4_128",
                                                                    "RC2_CBC_40",
                                                                    "IDEA_CBC",
                                                                    "DES40_CBC",
                                                                    "DES_CBC_40",
                                                                    "DES_CBC",
                                                                    "3DES_EDE_CBC",
                                                                    "SEED_CBC",
                                                                    "AES_128_CBC",
                                                                    "AES_256_CBC",
                                                                    "AES_128_GCM",
                                                                    "AES_256_GCM",
                                                                    "AES_128_CCM",
                                                                    "AES_256_CCM",
                                                                    "AES_128_CCM_8",
                                                                    "AES_256_CCM_8",
                                                                    "CAMELIA_128_CBC",
                                                                    "CAMELIA_256_CBC",
                                                                    "CAMELIA_128_GCM",
                                                                    "CAMELIA_256_GCM",
                                                                    "ARIA_128_CBC",
                                                                    "ARIA_256_CBC",
                                                                    "ARIA_128_GCM",
                                                                    "ARIA_256_GCM"};

static const char* const __TLS_HASH[] =                            {"NULL",
                                                                    "MD5",
                                                                    "SHA",
                                                                    "SHA256",
                                                                    "SHA384"};

static void tlss_dump(void* data, unsigned int len)
{
    int i;
    for (i = 0; i < len; ++i)
        printf("%02x", ((uint8_t*)data)[i]);
}

static void tlss_print_cipher_suite(uint16_t cipher_suite)
{
    TLS_KEY_EXCHANGE key_echange;
    TLS_CIPHER cipher;
    TLS_HASH hash;
    bool exported;

    switch (cipher_suite)
    {
    case TLS_EMPTY_RENEGOTIATION_INFO_SCSV:
        printf("TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n");
        return;
    case TLS_FALLBACK_SCSV:
        printf("TLS_FALLBACK_SCSV\n");
        return;
    default:
        break;
    }

    switch (cipher_suite)
    {
    case TLS_RSA_EXPORT_WITH_RC4_40_MD5:
    case TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5:
    case TLS_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_anon_EXPORT_WITH_RC4_40_MD5:
    case TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA:
    case TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA:
    case TLS_KRB5_EXPORT_WITH_RC4_40_SHA:
    case TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5:
    case TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5:
    case TLS_KRB5_EXPORT_WITH_RC4_40_MD5:
        exported = true;
        break;
    default:
        exported = false;
    }

    switch (cipher_suite)
    {
    case TLS_NULL_WITH_NULL_NULL:
        key_echange = TLS_KEY_EXCHANGE_NULL;
        break;
    case TLS_RSA_WITH_NULL_MD5:
    case TLS_RSA_WITH_NULL_SHA:
    case TLS_RSA_WITH_RC4_128_MD5:
    case TLS_RSA_WITH_RC4_128_SHA:
    case TLS_RSA_WITH_IDEA_CBC_SHA:
    case TLS_RSA_WITH_DES_CBC_SHA:
    case TLS_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_RSA_WITH_AES_128_CBC_SHA:
    case TLS_RSA_WITH_AES_256_CBC_SHA:
    case TLS_RSA_EXPORT_WITH_RC4_40_MD5:
    case TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5:
    case TLS_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_RSA_WITH_NULL_SHA256:
    case TLS_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_RSA_WITH_SEED_CBC_SHA:
    case TLS_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384:
    case TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_RSA_WITH_AES_128_CCM:
    case TLS_RSA_WITH_AES_256_CCM:
    case TLS_RSA_WITH_AES_128_CCM_8:
    case TLS_RSA_WITH_AES_256_CCM_8:
        key_echange = TLS_KEY_EXCHANGE_RSA;
        break;
    case TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_DSS_WITH_DES_CBC_SHA:
    case TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_128_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_256_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_256_CBC_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_DSS_WITH_SEED_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_AES_256_GCM_SHA384:
    case TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384:
        key_echange = TLS_KEY_EXCHANGE_DH_DSS;
        break;
    case TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_RSA_WITH_DES_CBC_SHA:
    case TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_128_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_256_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_RSA_WITH_SEED_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384:
        key_echange = TLS_KEY_EXCHANGE_DH_RSA;
        break;
    case TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DHE_DSS_WITH_DES_CBC_SHA:
    case TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_128_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_256_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_256_CBC_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DHE_DSS_WITH_SEED_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384:
        key_echange = TLS_KEY_EXCHANGE_DHE_DSS;
        break;
    case TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DHE_RSA_WITH_DES_CBC_SHA:
    case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:
    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DHE_RSA_WITH_SEED_CBC_SHA:
    case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_AES_128_CCM:
    case TLS_DHE_RSA_WITH_AES_256_CCM:
    case TLS_DHE_RSA_WITH_AES_128_CCM_8:
    case TLS_DHE_RSA_WITH_AES_256_CCM_8:
        key_echange = TLS_KEY_EXCHANGE_DHE_RSA;
        break;
    case TLS_DH_anon_EXPORT_WITH_RC4_40_MD5:
    case TLS_DH_anon_WITH_RC4_128_MD5:
    case TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_anon_WITH_DES_CBC_SHA:
    case TLS_DH_anon_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_anon_WITH_AES_128_CBC_SHA:
    case TLS_DH_anon_WITH_AES_256_CBC_SHA:
    case TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_anon_WITH_AES_128_CBC_SHA256:
    case TLS_DH_anon_WITH_AES_256_CBC_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_anon_WITH_SEED_CBC_SHA:
    case TLS_DH_anon_WITH_AES_128_GCM_SHA256:
    case TLS_DH_anon_WITH_AES_256_GCM_SHA384:
    case TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_anon_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_anon_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_anon_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_anon_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384:
        key_echange = TLS_KEY_EXCHANGE_DH_anon;
        break;
    case TLS_KRB5_WITH_DES_CBC_SHA:
    case TLS_KRB5_WITH_3DES_EDE_CBC_SHA:
    case TLS_KRB5_WITH_RC4_128_SHA:
    case TLS_KRB5_WITH_IDEA_CBC_SHA:
    case TLS_KRB5_WITH_DES_CBC_MD5:
    case TLS_KRB5_WITH_3DES_EDE_CBC_MD5:
    case TLS_KRB5_WITH_RC4_128_MD5:
    case TLS_KRB5_WITH_IDEA_CBC_MD5:
    case TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA:
    case TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA:
    case TLS_KRB5_EXPORT_WITH_RC4_40_SHA:
    case TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5:
    case TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5:
    case TLS_KRB5_EXPORT_WITH_RC4_40_MD5:
        key_echange = TLS_KEY_EXCHANGE_KRB5;
        break;
    case TLS_PSK_WITH_NULL_SHA:
    case TLS_PSK_WITH_RC4_128_SHA:
    case TLS_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_PSK_WITH_AES_128_CBC_SHA:
    case TLS_PSK_WITH_AES_256_CBC_SHA:
    case TLS_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_PSK_WITH_NULL_SHA256:
    case TLS_PSK_WITH_NULL_SHA384:
    case TLS_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_PSK_WITH_ARIA_128_GCM_SHA256:
    case TLS_PSK_WITH_ARIA_256_GCM_SHA384:
    case TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_PSK_WITH_AES_128_CCM:
    case TLS_PSK_WITH_AES_256_CCM:
    case TLS_PSK_WITH_AES_128_CCM_8:
    case TLS_PSK_WITH_AES_256_CCM_8:
    case TLS_PSK_DHE_WITH_AES_128_CCM_8:
    case TLS_PSK_DHE_WITH_AES_256_CCM_8:
        key_echange = TLS_KEY_EXCHANGE_PSK;
        break;
    case TLS_DHE_PSK_WITH_NULL_SHA:
    case TLS_DHE_PSK_WITH_RC4_128_SHA:
    case TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_PSK_WITH_AES_128_CBC_SHA:
    case TLS_DHE_PSK_WITH_AES_256_CBC_SHA:
    case TLS_DHE_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_NULL_SHA256:
    case TLS_DHE_PSK_WITH_NULL_SHA384:
    case TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_AES_128_CCM:
    case TLS_DHE_PSK_WITH_AES_256_CCM:
        key_echange = TLS_KEY_EXCHANGE_DHE_PSK;
        break;
    case TLS_RSA_PSK_WITH_NULL_SHA:
    case TLS_RSA_PSK_WITH_RC4_128_SHA:
    case TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_RSA_PSK_WITH_AES_128_CBC_SHA:
    case TLS_RSA_PSK_WITH_AES_256_CBC_SHA:
    case TLS_RSA_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_RSA_PSK_WITH_NULL_SHA256:
    case TLS_RSA_PSK_WITH_NULL_SHA384:
        key_echange = TLS_KEY_EXCHANGE_RSA_PSK;
        break;
    case TLS_ECDH_ECDSA_WITH_NULL_SHA:
    case TLS_ECDH_ECDSA_WITH_RC4_128_SHA:
    case TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:
        key_echange = TLS_KEY_EXCHANGE_ECDH_ECDSA;
        break;
    case TLS_ECDHE_ECDSA_WITH_NULL_SHA:
    case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:
    case TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CCM:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CCM:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8:
    case TLS_ECDH_RSA_WITH_NULL_SHA:
    case TLS_ECDH_RSA_WITH_RC4_128_SHA:
    case TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384:
        key_echange = TLS_KEY_EXCHANGE_ECDH_RSA;
        break;
    case TLS_ECDHE_RSA_WITH_NULL_SHA:
    case TLS_ECDHE_RSA_WITH_RC4_128_SHA:
    case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:
        key_echange = TLS_KEY_EXCHANGE_ECDHE_RSA;
        break;
    case TLS_ECDH_anon_WITH_NULL_SHA:
    case TLS_ECDH_anon_WITH_RC4_128_SHA:
    case TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_anon_WITH_AES_128_CBC_SHA:
    case TLS_ECDH_anon_WITH_AES_256_CBC_SHA:
        key_echange = TLS_KEY_EXCHANGE_ECDH_anon;
        break;
    case TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_WITH_AES_256_CBC_SHA:
        key_echange = TLS_KEY_EXCHANGE_SRP_SHA;
        break;
    case TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA:
        key_echange = TLS_KEY_EXCHANGE_SRP_SHA_RSA;
        break;
    case TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA:
        key_echange = TLS_KEY_EXCHANGE_SRP_SHA_DSS;
        break;
    case TLS_ECDHE_PSK_WITH_RC4_128_SHA:
    case TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_ECDHE_PSK_WITH_NULL_SHA:
    case TLS_ECDHE_PSK_WITH_NULL_SHA256:
    case TLS_ECDHE_PSK_WITH_NULL_SHA384:
    case TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:
        key_echange = TLS_KEY_EXCHANGE_ECDHE_PSK;
        break;
    default:
        key_echange = TLS_KEY_EXCHANGE_UNKNOWN;
    }

    switch (cipher_suite)
    {
    case TLS_NULL_WITH_NULL_NULL:
    case TLS_RSA_WITH_NULL_MD5:
    case TLS_RSA_WITH_NULL_SHA:
    case TLS_PSK_WITH_NULL_SHA:
    case TLS_DHE_PSK_WITH_NULL_SHA:
    case TLS_RSA_PSK_WITH_NULL_SHA:
    case TLS_RSA_WITH_NULL_SHA256:
    case TLS_PSK_WITH_NULL_SHA256:
    case TLS_PSK_WITH_NULL_SHA384:
    case TLS_DHE_PSK_WITH_NULL_SHA256:
    case TLS_DHE_PSK_WITH_NULL_SHA384:
    case TLS_RSA_PSK_WITH_NULL_SHA256:
    case TLS_RSA_PSK_WITH_NULL_SHA384:
    case TLS_ECDH_ECDSA_WITH_NULL_SHA:
    case TLS_ECDHE_ECDSA_WITH_NULL_SHA:
    case TLS_ECDH_RSA_WITH_NULL_SHA:
    case TLS_ECDHE_RSA_WITH_NULL_SHA:
    case TLS_ECDH_anon_WITH_NULL_SHA:
    case TLS_ECDHE_PSK_WITH_NULL_SHA:
    case TLS_ECDHE_PSK_WITH_NULL_SHA256:
    case TLS_ECDHE_PSK_WITH_NULL_SHA384:
        cipher = TLS_CIPHER_NULL;
        break;
    case TLS_RSA_EXPORT_WITH_RC4_40_MD5:
    case TLS_DH_anon_EXPORT_WITH_RC4_40_MD5:
    case TLS_KRB5_EXPORT_WITH_RC4_40_SHA:
    case TLS_KRB5_EXPORT_WITH_RC4_40_MD5:
        cipher = TLS_CIPHER_RC4_40;
        break;
    case TLS_RSA_WITH_RC4_128_MD5:
    case TLS_RSA_WITH_RC4_128_SHA:
    case TLS_DH_anon_WITH_RC4_128_MD5:
    case TLS_KRB5_WITH_RC4_128_SHA:
    case TLS_KRB5_WITH_RC4_128_MD5:
    case TLS_PSK_WITH_RC4_128_SHA:
    case TLS_DHE_PSK_WITH_RC4_128_SHA:
    case TLS_RSA_PSK_WITH_RC4_128_SHA:
    case TLS_ECDH_ECDSA_WITH_RC4_128_SHA:
    case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:
    case TLS_ECDH_RSA_WITH_RC4_128_SHA:
    case TLS_ECDHE_RSA_WITH_RC4_128_SHA:
    case TLS_ECDH_anon_WITH_RC4_128_SHA:
    case TLS_ECDHE_PSK_WITH_RC4_128_SHA:
        cipher = TLS_CIPHER_RC4_128;
        break;
    case TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5:
    case TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA:
    case TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5:
        cipher = TLS_CIPHER_RC2_CBC_40;
        break;
    case TLS_RSA_WITH_IDEA_CBC_SHA:
    case TLS_KRB5_WITH_IDEA_CBC_SHA:
    case TLS_KRB5_WITH_IDEA_CBC_MD5:
        cipher = TLS_CIPHER_IDEA_CBC;
        break;
    case TLS_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA:
        cipher = TLS_CIPHER_DES40_CBC;
        break;
    case TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA:
    case TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5:
        cipher = TLS_CIPHER_DES_CBC_40;
        break;
    case TLS_RSA_WITH_DES_CBC_SHA:
    case TLS_DH_DSS_WITH_DES_CBC_SHA:
    case TLS_DH_RSA_WITH_DES_CBC_SHA:
    case TLS_DHE_DSS_WITH_DES_CBC_SHA:
    case TLS_DHE_RSA_WITH_DES_CBC_SHA:
    case TLS_DH_anon_WITH_DES_CBC_SHA:
    case TLS_KRB5_WITH_DES_CBC_SHA:
    case TLS_KRB5_WITH_DES_CBC_MD5:
        cipher = TLS_CIPHER_DES_CBC;
        break;
    case TLS_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_anon_WITH_3DES_EDE_CBC_SHA:
    case TLS_KRB5_WITH_3DES_EDE_CBC_SHA:
    case TLS_KRB5_WITH_3DES_EDE_CBC_MD5:
    case TLS_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA:
        cipher = TLS_CIPHER_3DES_EDE_CBC;
        break;
    case TLS_RSA_WITH_AES_128_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_128_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_128_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_128_CBC_SHA:
    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:
    case TLS_DH_anon_WITH_AES_128_CBC_SHA:
    case TLS_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_AES_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_DH_anon_WITH_AES_128_CBC_SHA256:
    case TLS_PSK_WITH_AES_128_CBC_SHA:
    case TLS_DHE_PSK_WITH_AES_128_CBC_SHA:
    case TLS_RSA_PSK_WITH_AES_128_CBC_SHA:
    case TLS_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDH_anon_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256:
        cipher = TLS_CIPHER_AES_128_CBC;
        break;
    case TLS_RSA_WITH_AES_256_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_256_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_256_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_256_CBC_SHA:
    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:
    case TLS_DH_anon_WITH_AES_256_CBC_SHA:
    case TLS_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_DH_DSS_WITH_AES_256_CBC_SHA256:
    case TLS_DH_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_DHE_DSS_WITH_AES_256_CBC_SHA256:
    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_DH_anon_WITH_AES_256_CBC_SHA256:
    case TLS_PSK_WITH_AES_256_CBC_SHA:
    case TLS_DHE_PSK_WITH_AES_256_CBC_SHA:
    case TLS_RSA_PSK_WITH_AES_256_CBC_SHA:
    case TLS_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_RSA_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDH_anon_WITH_AES_256_CBC_SHA:
    case TLS_SRP_SHA_WITH_AES_256_CBC_SHA:
    case TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA:
    case TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384:
        cipher = TLS_CIPHER_AES_256_CBC;
        break;
    case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256:
        cipher = TLS_CIPHER_CAMELIA_128_CBC;
        break;
    case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:
        cipher = TLS_CIPHER_CAMELIA_256_CBC;
        break;
    case TLS_RSA_WITH_SEED_CBC_SHA:
    case TLS_DH_DSS_WITH_SEED_CBC_SHA:
    case TLS_DH_RSA_WITH_SEED_CBC_SHA:
    case TLS_DHE_DSS_WITH_SEED_CBC_SHA:
    case TLS_DHE_RSA_WITH_SEED_CBC_SHA:
    case TLS_DH_anon_WITH_SEED_CBC_SHA:
        cipher = TLS_CIPHER_SEED_CBC;
        break;
    case TLS_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_AES_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_AES_128_GCM_SHA256:
    case TLS_DH_anon_WITH_AES_128_GCM_SHA256:
    case TLS_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256:
        cipher = TLS_CIPHER_AES_128_GCM;
        break;
    case TLS_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_DH_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_DSS_WITH_AES_256_GCM_SHA384:
    case TLS_DH_DSS_WITH_AES_256_GCM_SHA384:
    case TLS_DH_anon_WITH_AES_256_GCM_SHA384:
    case TLS_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384:
        cipher = TLS_CIPHER_AES_256_GCM;
        break;
    case TLS_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_anon_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256:
        cipher = TLS_CIPHER_ARIA_128_CBC;
        break;
    case TLS_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_anon_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384:
        cipher = TLS_CIPHER_ARIA_256_CBC;
        break;
    case TLS_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_anon_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_PSK_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256:
        cipher = TLS_CIPHER_ARIA_128_GCM;
        break;
    case TLS_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_anon_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_PSK_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384:
        cipher = TLS_CIPHER_ARIA_128_GCM;
        break;
    case TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256:
        cipher = TLS_CIPHER_CAMELIA_128_GCM;
        break;
    case TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384:
        cipher = TLS_CIPHER_CAMELIA_256_GCM;
        break;
    case TLS_RSA_WITH_AES_128_CCM:
    case TLS_DHE_RSA_WITH_AES_128_CCM:
    case TLS_PSK_WITH_AES_128_CCM:
    case TLS_DHE_PSK_WITH_AES_128_CCM:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CCM:
        cipher = TLS_CIPHER_AES_128_CCM;
        break;
    case TLS_RSA_WITH_AES_256_CCM:
    case TLS_DHE_RSA_WITH_AES_256_CCM:
    case TLS_PSK_WITH_AES_256_CCM:
    case TLS_DHE_PSK_WITH_AES_256_CCM:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CCM:
        cipher = TLS_CIPHER_AES_256_CCM;
        break;
    case TLS_RSA_WITH_AES_128_CCM_8:
    case TLS_DHE_RSA_WITH_AES_128_CCM_8:
    case TLS_PSK_WITH_AES_128_CCM_8:
    case TLS_PSK_DHE_WITH_AES_128_CCM_8:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
        cipher = TLS_CIPHER_AES_128_CCM_8;
        break;
    case TLS_RSA_WITH_AES_256_CCM_8:
    case TLS_DHE_RSA_WITH_AES_256_CCM_8:
    case TLS_PSK_WITH_AES_256_CCM_8:
    case TLS_PSK_DHE_WITH_AES_256_CCM_8:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8:
        cipher = TLS_CIPHER_AES_256_CCM_8;
        break;
    default:
        cipher = TLS_CIPHER_UNKNOWN;
    }

    switch (cipher_suite)
    {
    case TLS_NULL_WITH_NULL_NULL:
        hash = TLS_HASH_NULL;
        break;
    case TLS_RSA_WITH_NULL_MD5:
    case TLS_RSA_EXPORT_WITH_RC4_40_MD5:
    case TLS_RSA_WITH_RC4_128_MD5:
    case TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5:
    case TLS_DH_anon_EXPORT_WITH_RC4_40_MD5:
    case TLS_DH_anon_WITH_RC4_128_MD5:
    case TLS_KRB5_WITH_DES_CBC_MD5:
    case TLS_KRB5_WITH_3DES_EDE_CBC_MD5:
    case TLS_KRB5_WITH_RC4_128_MD5:
    case TLS_KRB5_WITH_IDEA_CBC_MD5:
    case TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5:
    case TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5:
    case TLS_KRB5_EXPORT_WITH_RC4_40_MD5:
        hash = TLS_HASH_MD5;
        break;
    case TLS_RSA_WITH_NULL_SHA:
    case TLS_RSA_WITH_RC4_128_SHA:
    case TLS_RSA_WITH_IDEA_CBC_SHA:
    case TLS_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_RSA_WITH_DES_CBC_SHA:
    case TLS_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_DSS_WITH_DES_CBC_SHA:
    case TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_RSA_WITH_DES_CBC_SHA:
    case TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DHE_DSS_WITH_DES_CBC_SHA:
    case TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DHE_RSA_WITH_DES_CBC_SHA:
    case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA:
    case TLS_DH_anon_WITH_DES_CBC_SHA:
    case TLS_DH_anon_WITH_3DES_EDE_CBC_SHA:
    case TLS_KRB5_WITH_DES_CBC_SHA:
    case TLS_KRB5_WITH_3DES_EDE_CBC_SHA:
    case TLS_KRB5_WITH_RC4_128_SHA:
    case TLS_KRB5_WITH_IDEA_CBC_SHA:
    case TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA:
    case TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA:
    case TLS_KRB5_EXPORT_WITH_RC4_40_SHA:
    case TLS_PSK_WITH_NULL_SHA:
    case TLS_DHE_PSK_WITH_NULL_SHA:
    case TLS_RSA_PSK_WITH_NULL_SHA:
    case TLS_RSA_WITH_AES_128_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_128_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_128_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_128_CBC_SHA:
    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:
    case TLS_DH_anon_WITH_AES_128_CBC_SHA:
    case TLS_RSA_WITH_AES_256_CBC_SHA:
    case TLS_DH_DSS_WITH_AES_256_CBC_SHA:
    case TLS_DH_RSA_WITH_AES_256_CBC_SHA:
    case TLS_DHE_DSS_WITH_AES_256_CBC_SHA:
    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:
    case TLS_DH_anon_WITH_AES_256_CBC_SHA:
    case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA:
    case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA:
    case TLS_PSK_WITH_RC4_128_SHA:
    case TLS_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_PSK_WITH_AES_128_CBC_SHA:
    case TLS_PSK_WITH_AES_256_CBC_SHA:
    case TLS_DHE_PSK_WITH_RC4_128_SHA:
    case TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_DHE_PSK_WITH_AES_128_CBC_SHA:
    case TLS_DHE_PSK_WITH_AES_256_CBC_SHA:
    case TLS_RSA_PSK_WITH_RC4_128_SHA:
    case TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_RSA_PSK_WITH_AES_128_CBC_SHA:
    case TLS_RSA_PSK_WITH_AES_256_CBC_SHA:
    case TLS_RSA_WITH_SEED_CBC_SHA:
    case TLS_DH_DSS_WITH_SEED_CBC_SHA:
    case TLS_DH_RSA_WITH_SEED_CBC_SHA:
    case TLS_DHE_DSS_WITH_SEED_CBC_SHA:
    case TLS_DHE_RSA_WITH_SEED_CBC_SHA:
    case TLS_DH_anon_WITH_SEED_CBC_SHA:
    case TLS_ECDH_ECDSA_WITH_NULL_SHA:
    case TLS_ECDH_ECDSA_WITH_RC4_128_SHA:
    case TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_NULL_SHA:
    case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:
    case TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDH_RSA_WITH_NULL_SHA:
    case TLS_ECDH_RSA_WITH_RC4_128_SHA:
    case TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_NULL_SHA:
    case TLS_ECDHE_RSA_WITH_RC4_128_SHA:
    case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
    case TLS_ECDH_anon_WITH_NULL_SHA:
    case TLS_ECDH_anon_WITH_RC4_128_SHA:
    case TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDH_anon_WITH_AES_128_CBC_SHA:
    case TLS_ECDH_anon_WITH_AES_256_CBC_SHA:
    case TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA:
    case TLS_SRP_SHA_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA:
    case TLS_SRP_SHA_WITH_AES_256_CBC_SHA:
    case TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA:
    case TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_RC4_128_SHA:
    case TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA:
    case TLS_ECDHE_PSK_WITH_NULL_SHA:
        hash = TLS_HASH_SHA;
        break;
    case TLS_RSA_WITH_NULL_SHA256:
    case TLS_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_DH_DSS_WITH_AES_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_AES_256_CBC_SHA256:
    case TLS_DH_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_DHE_DSS_WITH_AES_256_CBC_SHA256:
    case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:
    case TLS_DH_anon_WITH_AES_128_CBC_SHA256:
    case TLS_DH_anon_WITH_AES_256_CBC_SHA256:
    case TLS_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_AES_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_AES_128_GCM_SHA256:
    case TLS_DH_anon_WITH_AES_128_GCM_SHA256:
    case TLS_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_AES_128_GCM_SHA256:
    case TLS_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_PSK_WITH_NULL_SHA256:
    case TLS_DHE_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_NULL_SHA256:
    case TLS_RSA_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_NULL_SHA256:
    case TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256:
    case TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256:
    case TLS_ECDHE_PSK_WITH_NULL_SHA256:
    case TLS_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_DH_anon_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256:
    case TLS_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256:
    case TLS_DH_anon_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256:
    case TLS_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_PSK_WITH_ARIA_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256:
    case TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256:
    case TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256:
    case TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256:
        hash = TLS_HASH_SHA256;
        break;
    case TLS_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_DH_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_DSS_WITH_AES_256_GCM_SHA384:
    case TLS_DH_DSS_WITH_AES_256_GCM_SHA384:
    case TLS_DH_anon_WITH_AES_256_GCM_SHA384:
    case TLS_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_AES_256_GCM_SHA384:
    case TLS_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_PSK_WITH_NULL_SHA384:
    case TLS_DHE_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_NULL_SHA384:
    case TLS_RSA_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_RSA_PSK_WITH_NULL_SHA384:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:
    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384:
    case TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384:
    case TLS_ECDHE_PSK_WITH_NULL_SHA384:
    case TLS_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_DH_anon_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384:
    case TLS_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384:
    case TLS_DH_anon_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384:
    case TLS_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_PSK_WITH_ARIA_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384:
    case TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384:
    case TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384:
    case TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:
        hash = TLS_HASH_SHA384;
        break;
    case TLS_RSA_WITH_AES_128_CCM:
    case TLS_RSA_WITH_AES_256_CCM:
    case TLS_DHE_RSA_WITH_AES_128_CCM:
    case TLS_DHE_RSA_WITH_AES_256_CCM:
    case TLS_RSA_WITH_AES_128_CCM_8:
    case TLS_RSA_WITH_AES_256_CCM_8:
    case TLS_DHE_RSA_WITH_AES_128_CCM_8:
    case TLS_DHE_RSA_WITH_AES_256_CCM_8:
    case TLS_PSK_WITH_AES_128_CCM:
    case TLS_PSK_WITH_AES_256_CCM:
    case TLS_DHE_PSK_WITH_AES_128_CCM:
    case TLS_DHE_PSK_WITH_AES_256_CCM:
    case TLS_PSK_WITH_AES_128_CCM_8:
    case TLS_PSK_WITH_AES_256_CCM_8:
    case TLS_PSK_DHE_WITH_AES_128_CCM_8:
    case TLS_PSK_DHE_WITH_AES_256_CCM_8:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CCM:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CCM:
    case TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:
    case TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8:
        hash = TLS_HASH_NIL;
        break;
    default:
        hash = TLS_HASH_UNKNOWN;
    }
    if (key_echange != TLS_KEY_EXCHANGE_UNKNOWN)
    {
        printf("TLS_%s_", __TLS_KEY_ECHANGE[key_echange]);
        if (exported)
            printf("EXPORT_");
        printf("WITH_%s", __TLS_CIPHER[cipher]);
        if (hash != TLS_HASH_NIL)
            printf("_%s", __TLS_HASH[hash]);
        printf("\n");
    }
    else
        printf("{%#02X, %#02X}\n", (cipher_suite >> 8) & 0xff, cipher_suite & 0xff);
}

static void tlss_print_compression_method(uint8_t compression_method)
{
    switch (compression_method)
    {
    case TLS_COMPRESSION_NULL:
        printf("NULL\n");
        break;
    case TLS_COMPRESSION_DEFLATE:
        printf("DEFLATE\n");
        break;
    case TLS_COMPRESSION_LZS:
        printf("LZS\n");
        break;
    default:
        printf("%#02X\n", compression_method);
    }
}
#endif //TLS_DEBUG_REQUESTS

static void tlss_set_state(TLSS_TCB* tcb, TLSS_STATE new_state)
{
#if (TLS_DEBUG_REQUESTS)
    printf("TLS: %s -> %s\n", __TLSS_STATES[tcb->state], __TLSS_STATES[new_state]);
#endif //TLS_DEBUG_REQUESTS
    tcb->state = new_state;
}

static HANDLE tlss_create_tcb(TLSS* tlss, HANDLE handle)
{
    TLSS_TCB* tcb;
    HANDLE tcb_handle;
    //TODO: multiple sessions support
    if (so_count(&tlss->tcbs))
        return INVALID_HANDLE;
    tcb_handle = so_allocate(&tlss->tcbs);
    if (tcb_handle == INVALID_HANDLE)
        return INVALID_HANDLE;
    tcb = so_get(&tlss->tcbs, tcb_handle);
    tcb->handle = handle;
    tcb->rx = tcb->tx = NULL;
    tcb->state = TLSS_STATE_CLIENT_HELLO;
    tcb->version = TLS_PROTOCOL_VERSION_UNSUPPORTED;
    tcb->cipher_suite = TLS_NULL_WITH_NULL_NULL;
    tcb->server_secure = tcb->client_secure = false;
    memset(&tcb->client_random, 0x00, sizeof(TLS_RANDOM));
    memset(&tcb->server_random, 0x00, sizeof(TLS_RANDOM));
    return tcb_handle;
}

//TODO: tlss_destroy_tcb

static HANDLE tlss_find_tcb_handle(TLSS* tlss, HANDLE handle)
{
    TLSS_TCB* tcb;
    HANDLE tcb_handle = INVALID_HANDLE;
    for (tcb_handle = so_first(&tlss->tcbs); tcb_handle != INVALID_HANDLE; tcb_handle = so_next(&tlss->tcbs, tcb_handle))
    {
        tcb = so_get(&tlss->tcbs, tcb_handle);
        if (tcb->handle == handle)
            return tcb_handle;
    }
    return tcb_handle;
}

static void tlss_tcp_rx(TLSS* tlss, HANDLE handle);

static inline void tlss_rx(TLSS* tlss, TLSS_TCB* tcb)
{
    if (tlss->offset < tlss->rx->data_size)
        tlss_tcp_rx(tlss, tcb->handle);
    else
    {
        io_reset(tlss->rx);
        tlss->offset = 0;
        tcp_read(tlss->tcpip, tcb->handle, tlss->rx, TLS_IO_SIZE);
    }
}

static unsigned int tlss_get_size(TLS_SIZE* tls_size)
{
    unsigned int res = (unsigned int)(tls_size->size_hi) << 16;
    res += (unsigned int)(tls_size->size_lo_be[0]) << 8;
    res += (unsigned int)(tls_size->size_lo_be[1]) << 0;
    return res;
}

static void tlss_set_size(TLS_SIZE* tls_size, unsigned int value)
{
    tls_size->size_hi = (value >> 16) & 0xff;
    tls_size->size_lo_be[0] = (value >> 8) & 0xff;
    tls_size->size_lo_be[1] = (value >> 0) & 0xff;
}

static void tlss_allocate_record(TLSS* tlss, TLSS_TCB* tcb, TLS_CONTENT_TYPE content_type)
{
    TLS_RECORD* rec;
    io_reset(tlss->tx);
    rec = io_data(tlss->tx);
    rec->content_type = content_type;
    rec->version.major = 3;
    rec->version.minor = (uint8_t)tcb->version;
    short2be(rec->record_length_be, 0);
    tlss->tx->data_size = sizeof(TLS_RECORD);
}

static void tlss_send_record(TLSS* tlss, TLSS_TCB* tcb)
{
    TCP_STACK* stack;
    TLS_RECORD* rec = io_data(tlss->tx);
    //Update full record len
    short2be(rec->record_length_be, tlss->tx->data_size - sizeof(TLS_RECORD));
    stack = io_push(tlss->tx, sizeof(TCP_STACK));
    stack->flags = TCP_PSH;
    tcp_write(tlss->tcpip, tcb->handle, tlss->tx);
}

static void tlss_append_server_hello(TLSS* tlss, TLSS_TCB* tcb)
{
    TLS_HANDSHAKE* handshake;
    TLS_HELLO* hello;

    unsigned short len = sizeof(TLS_HANDSHAKE);
    handshake = (TLS_HANDSHAKE*)((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size);
    handshake->message_type = TLS_HANDSHAKE_SERVER_HELLO;
    tlss_set_size(&handshake->message_length_be, 0);

    //1. Append generic header
    hello = (TLS_HELLO*)((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size + len);
    len += sizeof(TLS_HELLO);
    hello->version.major = 3;
    hello->version.minor = (uint8_t)tcb->version;
    memcpy(&hello->random, &tcb->server_random, sizeof(TLS_RANDOM));
    //always NULL session id
    hello->session_id_length = 0;

    //2. No session id, nothing to append

    //3. Append cipher suite
    short2be((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size + len, tcb->cipher_suite);
    len += 2;
    //4. append compression method
    *((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size + len) = TLS_COMPRESSION_NULL;
    ++len;

    //5. No extensions to append
    short2be((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size + len, 0);
    len += 2;

    //6. Update len at end
    tlss_set_size(&handshake->message_length_be, len - sizeof(TLS_HANDSHAKE));
    tlss->tx->data_size += len;

#if (TLS_DEBUG_REQUESTS)
    printf("TLS: serverHello\n");
    printf("Protocol version: 1.%d\n", hello->version.minor - 1);
    printf("Server random: ");
    tlss_dump(hello->random.gmt_unix_time_be, sizeof(uint32_t));
    printf(" ");
    tlss_dump(hello->random.random_bytes, TLS_RANDOM_SIZE);
    printf("\n");
    printf("Session ID: NULL\n");
    printf("cipher suite: ");
    tlss_print_cipher_suite(TLS_RSA_WITH_AES_128_CBC_SHA);
    printf("Compression method: NULL\n");
#endif //TLS_DEBUG_REQUESTS
}

static void tlss_append_certificate(TLSS* tlss, TLSS_TCB* tcb)
{
    TLS_HANDSHAKE* handshake;
    //1. Handshake record
    handshake = (TLS_HANDSHAKE*)((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size);
    handshake->message_type = TLS_HANDSHAKE_CERTIFICATE;
    tlss_set_size(&handshake->message_length_be, 2 * sizeof(TLS_SIZE) + tlss->cert_len);
    tlss->tx->data_size += sizeof(TLS_HANDSHAKE);

    //2. Certificate list
    tlss_set_size((TLS_SIZE*)((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size), sizeof(TLS_SIZE) + tlss->cert_len);
    tlss->tx->data_size += sizeof(TLS_SIZE);

    //3. Certificate list
    tlss_set_size((TLS_SIZE*)((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size), tlss->cert_len);
    tlss->tx->data_size += sizeof(TLS_SIZE);

    //4. Certificate itself
    memcpy((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size, tlss->cert, tlss->cert_len);
    tlss->tx->data_size += tlss->cert_len;
#if (TLS_DEBUG_REQUESTS)
    printf("TLS: certificate\n");
#endif //TLS_DEBUG_REQUESTS
}

static void tlss_append_server_hello_done(TLSS* tlss, TLSS_TCB* tcb)
{
    TLS_HANDSHAKE* handshake;
    handshake = (TLS_HANDSHAKE*)((uint8_t*)io_data(tlss->tx) + tlss->tx->data_size);
    handshake->message_type = TLS_HANDSHAKE_SERVER_HELLO_DONE;
    tlss_set_size(&handshake->message_length_be, 0);
    tlss->tx->data_size += sizeof(TLS_HANDSHAKE);
#if (TLS_DEBUG_REQUESTS)
    printf("TLS: serverHelloDone\n");
#endif //TLS_DEBUG_REQUESTS
}

static inline void tlss_tx_server_hello(TLSS* tlss, TLSS_TCB* tcb)
{
    tlss_allocate_record(tlss, tcb, TLS_CONTENT_HANDSHAKE);
    tlss_append_server_hello(tlss, tcb);
    tlss_append_certificate(tlss, tcb);
    tlss_append_server_hello_done(tlss, tcb);
    tlss_set_state(tcb, TLSS_STATE_CLIENT_KEY_EXCHANGE);
    tlss_send_record(tlss, tcb);
}

static void tlss_fsm(TLSS* tlss)
{
    HANDLE tcb_handle;
    TLSS_TCB* tcb;
    if (tlss->tcpip == INVALID_HANDLE)
        return;
    //TODO: multiple sessions support
    tcb_handle = so_first(&tlss->tcbs);
    //no active listen handles
    if (tcb_handle == INVALID_HANDLE)
        return;
    tcb = so_get(&tlss->tcbs, tcb_handle);

    switch (tcb->state)
    {
    case TLSS_STATE_SERVER_HELLO:
        tlss_tx_server_hello(tlss, tcb);
        break;
    default:
        tlss_rx(tlss, tcb);
    }
}

static void tlss_tx_alert(TLSS* tlss, HANDLE tcb_handle, TLS_ALERT_LEVEL alert_level, TLS_ALERT_DESCRIPTION alert_description)
{
    printd("TODO: TLS alert\n");
}

static inline void tlss_init(TLSS* tlss)
{
    tlss->tcpip = INVALID_HANDLE;
    tlss->user = INVALID_HANDLE;
    tlss->owner = INVALID_HANDLE;
    tlss->rx = NULL;
    tlss->tx = NULL;
    tlss->user_tx = NULL;
    tlss->user_tx_busy = false;
    tlss->cert = NULL;
    tlss->cert_len = 0;
    tlss->offset = 0;
    //relative time will be set on first clientHello request
    so_create(&tlss->tcbs, sizeof(TLSS_TCB), 1);
}

static inline void tlss_open(TLSS* tlss, HANDLE tcpip, HANDLE owner)
{
    if (tlss->tcpip != INVALID_HANDLE)
    {
        error(ERROR_ALREADY_CONFIGURED);
        return;
    }
    if (tlss->cert == NULL || tlss->cert_len == 0)
    {
        error(ERROR_NOT_CONFIGURED);
        return;
    }
    tlss->rx = io_create(TLS_IO_SIZE + sizeof(TCP_STACK));
    tlss->tx = io_create(TLS_IO_SIZE + sizeof(TCP_STACK));
    tlss->user_tx = io_create(TLS_IO_SIZE + sizeof(TCP_STACK));
    tlss->tcpip = tcpip;
    tlss->owner = owner;
}

static inline void tlss_close(TLSS* tlss)
{
    if (tlss->tcpip == INVALID_HANDLE)
    {
        error(ERROR_NOT_CONFIGURED);
        return;
    }
    //TODO: flush & close all handles
    tlss->tcpip = INVALID_HANDLE;
    tlss->owner = INVALID_HANDLE;
    io_destroy(tlss->rx);
    io_destroy(tlss->tx);
    tlss->rx = NULL;
    tlss->tx = NULL;
}

static inline void tlss_generate_server_random(TLSS* tlss, TLSS_TCB* tcb, void* random)
{
    memcpy(&tcb->server_random, io_data(tlss->tx), sizeof(TLS_RANDOM));
    tlss_set_state(tcb, TLSS_STATE_SERVER_HELLO);
}

static inline void tlss_generate_random(TLSS* tlss, HANDLE tcb_handle)
{
    TLSS_TCB* tcb = so_get(&tlss->tcbs, tcb_handle);
    //closed already
    if (tcb == NULL)
        return;
    if (tlss->tx->data_size < TLS_RANDOM_SIZE)
        return;
    switch (tcb->state)
    {
    case TLSS_STATE_GENERATE_SERVER_RANDOM:
        tlss_generate_server_random(tlss, tcb, io_data(tlss->tx));
        break;
    default:
        break;
    }
    tlss_fsm(tlss);
}

static inline void tlss_register_certificate(TLSS* tlss, uint8_t* cert, unsigned int len)
{
    if (tlss->cert != NULL)
    {
        error(ERROR_ALREADY_CONFIGURED);
        return;
    }
    if (cert == NULL || len == 0)
    {
        error(ERROR_INVALID_PARAMS);
        return;
    }
    tlss->cert = cert;
    tlss->cert_len = len;
}

static inline void tlss_premaster_decrypt(TLSS* tlss, HANDLE tcb_handle)
{
    int len;
    TLS_PREMASTER premaster;
    TLSS_TCB* tcb = so_get(&tlss->tcbs, tcb_handle);
    //closed already
    if (tcb == NULL)
        return;
    if (tcb->state != TLSS_STATE_DECRYPT_PREMASTER)
        return;
    if (tlss->tx->data_size < sizeof(TLS_PREMASTER_SIZE))
        return;

    len = eme_pkcs1_v1_15_decode(io_data(tlss->tx), TLS_PREMASTER_SIZE, &premaster, sizeof(TLS_PREMASTER));
    if (len < 0)
    {
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_DECRYPTION_FAILED);
#if (TLS_DEBUG)
        printf("TLS: premaster decryption failed\n");
#endif //TLS_DEBUG
        return;
    }
#if (TLS_DEBUG_SECRETS)
    printf("TLS: Premaster: ");
    tlss_dump(&premaster, sizeof(TLS_PREMASTER));
    printf("\n");
#endif //TLS_DEBUG_SECRETS

    //TODO: generate master secret

    //secure erase premaster
    memset(&premaster, 0x00, sizeof(TLS_PREMASTER));

    tlss_set_state(tcb, TLSS_STATE_CLIENT_KEY_EXCHANGE);
    tlss_fsm(tlss);
}

static inline void tlss_request(TLSS* tlss, IPC* ipc)
{
    switch (HAL_ITEM(ipc->cmd))
    {
    case IPC_OPEN:
        tlss_open(tlss, (HANDLE)ipc->param2, ipc->process);
        break;
    case IPC_CLOSE:
        tlss_close(tlss);
        break;
    case TLS_GENERATE_RANDOM:
        tlss_generate_random(tlss, (HANDLE)ipc->param1);
        break;
    case TLS_REGISTER_CERTIFICATE:
        tlss_register_certificate(tlss, (uint8_t*)ipc->param2, ipc->param3);
        break;
    case TLS_PREMASTER_DECRYPT:
        tlss_premaster_decrypt(tlss, (HANDLE)ipc->param1);
        break;
    default:
        error(ERROR_NOT_SUPPORTED);
    }
}

static inline void tlss_tcp_open(TLSS* tlss, HANDLE handle)
{
    HANDLE tcb_handle = tlss_create_tcb(tlss, handle);
    if (tcb_handle == INVALID_HANDLE)
    {
        tcp_close(tlss->tcpip, handle);
        return;
    }
#if (TLS_DEBUG)
///    tcp_get_remote_addr(hss->tcpip, handle, &session->remote_addr);
    printf("TLS: new session from ");
///    ip_print(&session->remote_addr);
    printf("\n");
#endif //TLS_DEBUG
    tlss_fsm(tlss);
}

static inline bool tlss_rx_change_cipher(TLSS* tlss, HANDLE tcb_handle, void* data, unsigned short len)
{
    TLSS_TCB* tcb = so_get(&tlss->tcbs, tcb_handle);
    if ((tcb->state != TLSS_STATE_CLIENT_KEY_EXCHANGE) || (len != 1) || (*((uint8_t*)data) != TLS_CHANGE_CIPHER_SPEC))
    {
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
        return true;
    }
    //TODO: check if master secret is set
    tcb->client_secure = true;
#if (TLS_DEBUG_REQUESTS)
    printf("TLS: (client) changeCipherSpec\n");
#endif //TLS_DEBUG_REQUESTS
    return false;
}

static inline bool tlss_rx_alert(TLSS* tlss, HANDLE tcb_handle, void* data, unsigned short len)
{
    printd("TODO: alert\n");
    dump(data, len);
    return true;
}

static inline bool tlss_rx_client_hello(TLSS* tlss, HANDLE tcb_handle, void* data, unsigned short len)
{
    int i;
    unsigned short cipher_suites_len;
    uint8_t compression_len;
    uint16_t tmp;
    uint8_t* cipher_suites;
    uint8_t* compression;
    TLS_HELLO* hello;
    TLSS_TCB* tcb = so_get(&tlss->tcbs, tcb_handle);
    hello = data;
    //1. Check state and clientHello header size
    if ((tcb->state != TLSS_STATE_CLIENT_HELLO) || (len < sizeof(TLS_HELLO)))
    {
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
        return true;
    }
    //2. Check protocol version
    if ((hello->version.major < 3) || (hello->version.minor < 1))
    {
#if (TLS_DEBUG)
        printf("TLS: Protocol version too old\n");
#endif //TLS_DEBUG_REQUESTS
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_PROTOCOL_VERSION);
        return true;
    }
    if ((hello->version.major > 3) || (hello->version.minor > 3))
        tcb->version = TLS_PROTOCOL_1_2;
    else
        tcb->version = (TLS_PROTOCOL_VERSION)hello->version.minor;
    //3. Copy random
    memcpy(&tcb->client_random, &hello->random, sizeof(TLS_RANDOM));
    //4. Ignore session, just check size
    data += sizeof(TLS_HELLO);
    len -= sizeof(TLS_HELLO);
    if (len < hello->session_id_length + 2)
    {
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
        return true;
    }
    data += hello->session_id_length;
    len -= hello->session_id_length;
    //5. Decode cipher suites and apply
    cipher_suites_len = be2short(data);
    data += 2;
    len -= 2;
    //also byte for compression len
    if (len <= cipher_suites_len)
    {
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
        return true;
    }
    cipher_suites = data;
    data += cipher_suites_len;
    len -= cipher_suites_len;
    for (i = 0; i < cipher_suites_len; i += 2)
    {
        tmp = be2short(cipher_suites + i);
        //Only one cipher suite supported for now
        if (tmp == TLS_RSA_WITH_AES_128_CBC_SHA)
        {
            tcb->cipher_suite = tmp;
            break;
        }
    }
    if (tcb->cipher_suite == TLS_NULL_WITH_NULL_NULL)
    {
#if (TLS_DEBUG)
        printf("TLS: Supported cipher suite not found\n");
#endif //TLS_DEBUG_REQUESTS
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_HANDSHAKE_FAILURE);
        return true;
    }
    //6. Decode and check compression
    compression_len = *((uint8_t*)data);
    ++data;
    --len;
    if (len < compression_len)
    {
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
        return true;
    }
    compression = data;
    data += compression_len;
    len -= compression_len;
    tmp = 0xffff;
    for (i = 0; i < compression_len; ++i)
    {
        //no compression supported for now
        if (compression[i] == TLS_COMPRESSION_NULL)
        {
            tmp = compression[i];
            break;
        }
    }
    if (tmp == 0xffff)
    {
#if (TLS_DEBUG)
        printf("TLS: Supported compression method not found\n");
#endif //TLS_DEBUG_REQUESTS
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_HANDSHAKE_FAILURE);
        return true;
    }

    //skip extensions
    tlss_set_state(tcb, TLSS_STATE_GENERATE_SERVER_RANDOM);
#if (TLS_DEBUG_REQUESTS)
    printf("TLS: clientHello\n");
    printf("Protocol version: %d.%d\n", hello->version.major - 2, hello->version.minor - 1);
    printf("Client random: ");
    tlss_dump(hello->random.gmt_unix_time_be, sizeof(uint32_t));
    printf(" ");
    tlss_dump(hello->random.random_bytes, TLS_RANDOM_SIZE);
    printf("\n");
    printf("Session ID: ");
    if (hello->session_id_length == 0)
        printf("NULL");
    else
        tlss_dump((uint8_t*)hello + sizeof(TLS_HELLO), hello->session_id_length);
    printf("\n");
    printf("cipher suites: \n");
    for (i = 0; i < cipher_suites_len; i += 2)
    {
        tmp = be2short(cipher_suites + i);
        if (tmp == tcb->cipher_suite)
            printf("*");
        tlss_print_cipher_suite(tmp);
    }
    printf("Compression methods:\n");
    for (i = 0; i < compression_len; ++i)
    {
        if (compression[i] == TLS_COMPRESSION_NULL)
            printf("*");
        tlss_print_compression_method(i);
    }
#endif //TLS_DEBUG_REQUESTS
    io_read(tlss->owner, HAL_IO_REQ(HAL_TLS, TLS_GENERATE_RANDOM), tcb_handle, tlss->tx, sizeof(TLS_RANDOM));
    return true;
}

static inline bool tlss_rx_client_key_exchange(TLSS* tlss, HANDLE tcb_handle, void* data, unsigned short len)
{
    TLSS_TCB* tcb = so_get(&tlss->tcbs, tcb_handle);
    if ((tcb->state != TLSS_STATE_CLIENT_KEY_EXCHANGE) || (len < TLS_PREMASTER_SIZE + 2) || (be2short(data) != TLS_PREMASTER_SIZE))
    {
        tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
        return true;
    }
    io_reset(tlss->tx);
    memcpy(io_data(tlss->tx), (uint8_t*)data + 2, TLS_PREMASTER_SIZE);
    tlss->tx->data_size = TLS_PREMASTER_SIZE;
    tlss_set_state(tcb, TLSS_STATE_DECRYPT_PREMASTER);
#if (TLS_DEBUG_REQUESTS)
    printf("TLS: clientKeyExchange\n");
#endif //TLS_DEBUG_REQUESTS

    io_write(tlss->owner, HAL_IO_REQ(HAL_TLS, TLS_PREMASTER_DECRYPT), tcb_handle, tlss->tx);
    return true;
}

static inline bool tlss_rx_handshakes(TLSS* tlss, HANDLE tcb_handle, void* data, unsigned short len)
{
    unsigned short offset, len_cur;
    TLS_HANDSHAKE* handshake;
    void* data_cur;
    bool answered;
    //iterate through handshake messages
    for (offset = 0; offset < len; offset += len_cur + sizeof(TLS_HANDSHAKE))
    {
        if (len - offset < sizeof(TLS_HANDSHAKE))
        {
            tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
            return true;
        }
        handshake = (TLS_HANDSHAKE*)((uint8_t*)data + offset);
        len_cur = tlss_get_size(&handshake->message_length_be);
        if (len_cur + sizeof(TLS_HANDSHAKE) > len - offset)
        {
            tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
            return true;
        }
        data_cur = (uint8_t*)data + offset + sizeof(TLS_HANDSHAKE);
        switch (handshake->message_type)
        {
        case TLS_HANDSHAKE_CLIENT_HELLO:
            answered = tlss_rx_client_hello(tlss, tcb_handle, data_cur, len_cur);
            break;
        case TLS_HANDSHAKE_CLIENT_KEY_EXCHANGE:
            answered = tlss_rx_client_key_exchange(tlss, tcb_handle, data_cur, len_cur);
            break;
        //TODO: not sure about others this time
//        TLS_HANDSHAKE_FINISHED = 20
        default:
#if (TLS_DEBUG)
            printf("TLS: unexpected handshake type: %d\n", handshake->message_type);
#endif //TLS_DEBUG
            tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
            answered = true;
        }
        if (answered)
            return true;
    }
    return false;
}

static inline bool tlss_rx_app(TLSS* tlss, HANDLE tcb_handle, void* data, unsigned short len)
{
    printd("TODO: app\n");
    dump(data, len);
    return true;
}

static void tlss_tcp_rx(TLSS* tlss, HANDLE handle)
{
    bool answered;
    TLS_RECORD* rec;
    unsigned short len;
    void* data;
    TLSS_TCB* tcb;
    HANDLE tcb_handle = tlss_find_tcb_handle(tlss, handle);
    answered = true;
    do {
        //closed before
        if (tcb_handle == INVALID_HANDLE)
        {
            answered = false;
            break;
        }
        //Empty records disabled by TLS
        if ((tlss->rx->data_size - tlss->offset) <= sizeof(TLS_RECORD))
        {
            tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
            break;
        }
        rec = (TLS_RECORD*)((uint8_t*)io_data(tlss->rx) + tlss->offset);
        //check TLS 1.0 - 1.2
        if ((rec->version.major != 3) || (rec->version.minor == 0) || (rec->version.minor > 3))
        {
            tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_PROTOCOL_VERSION);
            break;
        }
        len = be2short(rec->record_length_be);
        tlss->offset += sizeof(TLS_RECORD);
        if (len > tlss->rx->data_size - tlss->offset)
        {
            tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
            break;
        }
        data = (uint8_t*)io_data(tlss->rx) + tlss->offset;
        tlss->offset += len;
        tcb = so_get(&tlss->tcbs, tcb_handle);
        if (tcb->client_secure)
        {
            printf("TODO: cipher record decrypt\n");
            tlss_dump(data, len);
            printf("\n");
            printf("HANG\n");
            for (;;) {}
        }
        switch (rec->content_type)
        {
        case TLS_CONTENT_CHANGE_CIPHER:
            answered = tlss_rx_change_cipher(tlss, tcb_handle, data, len);
            break;
        case TLS_CONTENT_ALERT:
            answered = tlss_rx_alert(tlss, tcb_handle, data, len);
            break;
        case TLS_CONTENT_HANDSHAKE:
            answered = tlss_rx_handshakes(tlss, tcb_handle, data, len);
            break;
        case TLS_CONTENT_APP:
            answered = tlss_rx_app(tlss, tcb_handle, data, len);
            break;
        default:
#if (TLS_DEBUG)
            printf("TLS: unexpected message type: %d\n", rec->content_type);
#endif //TLS_DEBUG
            tlss_tx_alert(tlss, tcb_handle, TLS_ALERT_LEVEL_FATAL, TLS_ALERT_UNEXPECTED_MESSAGE);
        }
    } while (false);
    if (!answered)
        tlss_fsm(tlss);
}

static inline void tlss_tcp_request(TLSS* tlss, IPC* ipc)
{
    switch (HAL_ITEM(ipc->cmd))
    {
    case IPC_OPEN:
        tlss_tcp_open(tlss, (HANDLE)ipc->param1);
        break;
///    case IPC_CLOSE:
        //TODO:
    case IPC_READ:
        tlss_tcp_rx(tlss, (HANDLE)ipc->param1);
        break;
    case IPC_WRITE:
        if ((IO*)ipc->param2 == tlss->tx)
            tlss_fsm(tlss);
        else
        {
            printf("TODO: user data sent\n");
        }
        break;
    default:
        printf("got from tcp\n");
        error(ERROR_NOT_SUPPORTED);
    }
}

static inline void tlss_user_listen(TLSS* tlss, IPC* ipc)
{
    //just forward to tcp
    if (tlss->tcpip == INVALID_HANDLE)
    {
        error(ERROR_NOT_CONFIGURED);
        return;
    }
    if (tlss->user != INVALID_HANDLE)
    {
        error(ERROR_ALREADY_CONFIGURED);
        return;
    }
    tlss->user = ipc->process;
    //just forward to tcp
    ipc->param2 = tcp_listen(tlss->tcpip, ipc->param1);
}

static inline void tlss_user_close_listen(TLSS* tlss, IPC* ipc)
{
    //just forward to tcp
    if (tlss->user == INVALID_HANDLE)
    {
        error(ERROR_NOT_CONFIGURED);
        return;
    }
    tlss->user = INVALID_HANDLE;
    //just forward to tcp
    tcp_close_listen(tlss->tcpip, ipc->param1);
}

static inline void tlss_user_request(TLSS* tlss, IPC* ipc)
{
    //TODO:
//    TCP_GET_REMOTE_ADDR
//    TCP_GET_REMOTE_PORT
//    TCP_GET_LOCAL_PORT

    switch (HAL_ITEM(ipc->cmd))
    {
    case TCP_LISTEN:
        tlss_user_listen(tlss, ipc);
        break;
    case TCP_CLOSE_LISTEN:
        tlss_user_close_listen(tlss, ipc);
        break;
///    case IPC_CLOSE:
        //TODO:
///    case IPC_READ:
        //TODO:
///    case IPC_WRITE:
        //TODO:
///    case IPC_FLUSH:
        //TODO:
    default:
        printf("tls user request\n");
        error(ERROR_NOT_SUPPORTED);
    }
}

void tlss_main()
{
    IPC ipc;
    TLSS tlss;
    tlss_init(&tlss);
#if (TLS_DEBUG)
    open_stdout();
#endif //HS_DEBUG

    for (;;)
    {
        ipc_read(&ipc);
        switch (HAL_GROUP(ipc.cmd))
        {
        case HAL_TLS:
            tlss_request(&tlss, &ipc);
            break;
        case HAL_TCP:
            if (ipc.process == tlss.tcpip)
                tlss_tcp_request(&tlss, &ipc);
            else
                tlss_user_request(&tlss, &ipc);
            break;
        default:
            error(ERROR_NOT_SUPPORTED);
            break;
        }
        ipc_write(&ipc);
    }
}
